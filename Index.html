<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minecraft Skinpack Encryptor</title>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
body { font-family: monospace; background:#0f1720; color:#e0e0e0; margin:0; padding:20px;}
h1 { color:#06b6d4; }
#log { height:300px; overflow:auto; background:#0b1220; padding:10px; margin-top:10px; border-radius:5px; white-space:pre-wrap;}
input, button { margin:5px 0; padding:5px; width:100%; max-width:500px;}
@media(max-width:600px){ input, button { width:100%; } }
</style>
</head>
<body>
<h1>Minecraft Skinpack Encryptor</h1>
<label>Folder Input: <input type="file" id="folderInput" webkitdirectory directory multiple></label>
<label>or ZIP Input: <input type="file" id="zipInput" accept=".zip"></label>
<br>
<label>Pack Key (32 chars, default used if blank): <input type="text" id="packKey" maxlength="32" placeholder="s5s5ejuDru4uchuF2drUFuthaspAbepE"></label>
<br>
<label>Custom Manifest (optional): <input type="file" id="customManifest" accept=".json"></label>
<br>
<label><input type="checkbox" id="debugMode"> Debug Mode (save decrypted copies)</label>
<br>
<button id="encryptBtn">Encrypt Skinpack</button>
<pre id="log"></pre>

<script>
const skipFiles = ['manifest.json','pack_icon.png'];
const skipForce = ['contents.json','signatures.json'];

function log(msg){ 
    const l = document.getElementById('log'); 
    l.textContent += msg + '\n'; 
    l.scrollTop = l.scrollHeight; 
    return new Promise(r=>setTimeout(r,0)); // allow UI update
}

function randomKey32(){
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let key = '';
    for(let i=0;i<32;i++) key += chars.charAt(Math.floor(Math.random()*chars.length));
    return key;
}

async function sha256Base64(data){
    const hash = await crypto.subtle.digest('SHA-256', data);
    return btoa(String.fromCharCode(...new Uint8Array(hash)));
}

async function aesCFB8Encrypt(data, keyStr){
    const keyBytes = new TextEncoder().encode(keyStr);
    const iv = keyBytes.slice(0,16);
    const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, 'AES-CFB', true, ['encrypt']);
    return new Uint8Array(await crypto.subtle.encrypt({name:'AES-CFB', iv}, cryptoKey, data));
}

// Normalize paths so root matches Python
function normalizePath(path){
    path = path.replaceAll('\\','/');
    const parts = path.split('/');
    if(parts.length > 1) return parts.slice(1).join('/');
    return path;
}

document.getElementById('encryptBtn').addEventListener('click', async ()=>{
    const folderFiles = document.getElementById('folderInput').files;
    const zipFile = document.getElementById('zipInput').files[0];
    const customManifestFile = document.getElementById('customManifest').files[0] || null;
    const debug = document.getElementById('debugMode').checked;

    let packKey = document.getElementById('packKey').value;
    if(!packKey) packKey = 's5s5ejuDru4uchuF2drUFuthaspAbepE';
    if(packKey.length!==32){ alert('Pack key must be 32 chars'); return; }

    let fileMap = {};

    // Load folder
    if(folderFiles.length>0){
        for(const file of folderFiles){
            const path = normalizePath(file.webkitRelativePath);
            const content = await file.arrayBuffer();
            fileMap[path] = content;
        }
    }
    // Load zip
    else if(zipFile){
        const zipData = await zipFile.arrayBuffer();
        const zip = await JSZip.loadAsync(zipData);
        await Promise.all(Object.keys(zip.files).map(async path=>{
            const fileObj = zip.files[path];
            if(!fileObj.dir){
                const normPath = normalizePath(path);
                const content = await fileObj.async('arraybuffer');
                fileMap[normPath] = content;
            }
        }));
    }
    else { alert('Select a folder or zip file.'); return; }

    // Manifest detection
    let manifestPath = Object.keys(fileMap).find(p=>p.endsWith('manifest.json'));
    if(!manifestPath){ alert('manifest.json missing!'); return; }

    // Replace manifest if provided
    if(customManifestFile){
        const customManifestData = await customManifestFile.arrayBuffer();
        fileMap[manifestPath] = customManifestData;
        await log('Custom manifest loaded.');
    }

    const manifestData = fileMap[manifestPath];
    const manifestJSON = JSON.parse(new TextDecoder().decode(manifestData));
    const uuid = manifestJSON.header.uuid;
    if(!uuid || uuid.length!==36){ alert('manifest.json UUID invalid'); return; }
    await log('Manifest loaded from: ' + manifestPath);

    const contentsJSON = {version:1, content:[]};
    const zipOut = new JSZip();

    // Encrypt / add files with live logging
    for(const path in fileMap){
        const content = fileMap[path];
        let encrypt = true;
        let doNotAdd = false;

        if(path.startsWith('texts/')) encrypt=false;
        if(skipFiles.includes(path)) encrypt=false;
        if(skipForce.includes(path)){ encrypt=false; doNotAdd=true; }

        let encData;
        if(encrypt){
            const key = randomKey32();
            encData = await aesCFB8Encrypt(new Uint8Array(content), key);
            contentsJSON.content.push({key, path});
            await log(`Encrypted ${path} with key ${key}`);
        } else {
            encData = new Uint8Array(content);
            if(!doNotAdd){
                contentsJSON.content.push({path});
                await log(`Skipped ${path}`);
            } else {
                await log(`Unadded ${path}`);
            }
        }

        zipOut.file(path, encData);
        await new Promise(r=>setTimeout(r,0)); // yield to UI
    }

    // signatures.json
    const sigHash = await sha256Base64(fileMap[manifestPath]);
    const sigJSON = [{hash:sigHash, path:'manifest.json'}];
    const sigKey = randomKey32();
    const sigEnc = await aesCFB8Encrypt(new TextEncoder().encode(JSON.stringify(sigJSON, null,0)), sigKey);
    zipOut.file('signatures.json', sigEnc);
    contentsJSON.content.push({key:sigKey, path:'signatures.json'});
    await log('signatures.json encrypted');

    // contents.json with Python-compatible header
    const contentsEnc = await aesCFB8Encrypt(new TextEncoder().encode(JSON.stringify(contentsJSON, null,0)), packKey);
    const empty = new Uint8Array(256);
    const headerByte = new Uint8Array([0xfc,0xb9,0xcf,0x9b,0,0,0,0,0,0,0,0,0,0,0,0,0x24]);
    const uuidBytes = new TextEncoder().encode(uuid);
    const headerFinal = new Uint8Array([
        ...empty.slice(0,4),        
        ...headerByte,               
        ...uuidBytes,                
        ...empty.slice(53)           
    ]);
    const finalContents = new Uint8Array([...headerFinal,...contentsEnc]);
    zipOut.file('contents.json', finalContents);
    await log('contents.json encrypted (Python-compatible header)');

    if(debug){
        zipOut.file('contentsDecrypted.json', new TextEncoder().encode(JSON.stringify(contentsJSON,null,2)));
        zipOut.file('signaturesDecrypted.json', new TextEncoder().encode(JSON.stringify(sigJSON,null,2)));
        await log('Debug copies included.');
    }

    await log('Generating final ZIP...');
    const blob = await zipOut.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'EncryptedSkinpack.zip';
    a.click();
    await log('Encryption complete! Download started.');
});
</script>
</body>
</html>
